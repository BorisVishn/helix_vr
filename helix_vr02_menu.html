<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<title>Helix VR</title>
<style>body { margin:0; overflow:hidden; background:black; }</style>
</head>
<body>
<script type="module">
import * as THREE from 'https://esm.sh/three@0.160.0';
import { OrbitControls } from 'https://esm.sh/three@0.160.0/examples/jsm/controls/OrbitControls';
import { VRButton } from 'https://esm.sh/three@0.160.0/examples/jsm/webxr/VRButton';

const helixData = [{"residue": "M", "x": 2.3, "y": 0.0, "z": 0.0}, {"residue": "K", "x": -0.39939080863393966, "y": 2.265057831928078, "z": 1.5}, {"residue": "L", "x": -2.1612930278075893, "y": -0.7866463296490378, "z": 3.0}, {"residue": "L", "x": 1.1500000000000001, "y": -1.9918584287042087, "z": 4.5}, {"residue": "V", "x": 1.7619022191736495, "y": 1.47841150227904, "z": 6.0}, {"residue": "L", "x": -1.76190221917365, "y": 1.4784115022790396, "z": 7.5}, {"residue": "L", "x": -1.1499999999999995, "y": -1.991858428704209, "z": 9.0}, {"residue": "C", "x": 2.161293027807589, "y": -0.7866463296490382, "z": 10.5}, {"residue": "L", "x": 0.39939080863394055, "y": 2.265057831928078, "z": 12.0}, {"residue": "A", "x": -2.3, "y": 1.4083438190194562e-15, "z": 13.5}, {"residue": "S", "x": 0.39939080863394183, "y": -2.265057831928078, "z": 15.0}, {"residue": "D", "x": 2.16129302780759, "y": 0.7866463296490356, "z": 16.5}, {"residue": "G", "x": -1.1500000000000006, "y": 1.9918584287042083, "z": 18.0}, {"residue": "E", "x": -1.7619022191736518, "y": -1.4784115022790374, "z": 19.5}, {"residue": "Q", "x": 1.761902219173649, "y": -1.4784115022790407, "z": 21.0}, {"residue": "V", "x": 1.1500000000000044, "y": 1.991858428704206, "z": 22.5}, {"residue": "Y", "x": -2.1612930278075884, "y": 0.7866463296490395, "z": 24.0}, {"residue": "Q", "x": -0.39939080863393794, "y": -2.265057831928079, "z": 25.5}, {"residue": "V", "x": 2.3, "y": -2.8166876380389124e-15, "z": 27.0}, {"residue": "K", "x": -0.3993908086339324, "y": 2.2650578319280794, "z": 28.5}];

// ===== SCENE =====
const scene = new THREE.Scene();
scene.background = new THREE.Color(0x000000);

const camera = new THREE.PerspectiveCamera(70, window.innerWidth/window.innerHeight, 0.1, 200);
camera.position.set(0,1.6,6);

const renderer = new THREE.WebGLRenderer({antialias:true});
renderer.setSize(window.innerWidth,window.innerHeight);
renderer.xr.enabled = true;
document.body.appendChild(renderer.domElement);
document.body.appendChild(VRButton.createButton(renderer));

const controls = new OrbitControls(camera, renderer.domElement);
controls.target.set(0,1.5,0);
controls.update();

scene.add(new THREE.HemisphereLight(0xffffff,0x444444,1.2));
scene.add(new THREE.DirectionalLight(0xffffff,0.8));

// ===== HELIX =====
const helixGroup = new THREE.Group();
scene.add(helixGroup);

let groupDefs = {
  Hydrophobic: { letters:"GAVLIMFWP",color:0xFFD700, visible:true },
  Polar:       { letters:"STNQYC",   color:0x00CED1, visible:true },
  Positive:    { letters:"KRH",      color:0xFF4500, visible:true },
  Negative:    { letters:"DE",       color:0xDC143C, visible:true }
};

const sprites=[];

function makeSprite(letter){
  const canvas=document.createElement('canvas');
  canvas.width=canvas.height=256;
  const ctx=canvas.getContext('2d');
  ctx.font="Bold 180px Arial";
  ctx.textAlign="center";
  ctx.textBaseline="middle";
  ctx.fillText(letter,128,128);
  const tex=new THREE.CanvasTexture(canvas);
  const mat=new THREE.SpriteMaterial({map:tex,transparent:true});
  const s=new THREE.Sprite(mat);
  s.scale.set(0.5,0.5,1);
  return s;
}

const pts=[];
helixData.forEach(res=>{
  const p=new THREE.Vector3(res.x/2,res.y/2+1.5,-res.z/4);
  pts.push(p);
  const s=makeSprite(res.residue);
  s.position.copy(p);
  s.userData.letter=res.residue;
  helixGroup.add(s);
  sprites.push(s);
});

const ribbon=new THREE.Mesh(
  new THREE.TubeGeometry(new THREE.CatmullRomCurve3(pts),200,0.02,8,false),
  new THREE.MeshStandardMaterial({color:0xaaaaaa})
);
helixGroup.add(ribbon);

// ===== COLOR UPDATE =====
function recolorHelix(){
  sprites.forEach(s=>{
    let color=0x888888;
    let visible=false;

    for(const g of Object.values(groupDefs)){
      if(g.letters.includes(s.userData.letter)){
        color=g.color;
        visible=g.visible;
        break;
      }
    }

    const ctx=s.material.map.image.getContext('2d');
    ctx.clearRect(0,0,256,256);
    ctx.fillStyle="#" + color.toString(16).padStart(6,'0');
    ctx.font="Bold 180px Arial";
    ctx.textAlign="center";
    ctx.textBaseline="middle";
    ctx.fillText(s.userData.letter,128,128);
    s.material.map.needsUpdate=true;
    s.visible=visible;
  });
}
recolorHelix();

// ===== INPUT BOX =====
const inputBox=document.createElement("input");
inputBox.style.position="absolute";
inputBox.style.top="10px";
inputBox.style.left="10px";
inputBox.style.fontSize="20px";
inputBox.style.padding="5px";
inputBox.style.display="none";
document.body.appendChild(inputBox);

let currentEditGroup=null;

inputBox.addEventListener("keydown",e=>{
  if(e.key==="Enter" && currentEditGroup){
    groupDefs[currentEditGroup].letters=inputBox.value.toUpperCase().replace(/[^A-Z]/g,'');
    recolorHelix();
    inputBox.style.display="none";
  }
});

// ===== MENUS =====
const menuWorld=new THREE.Group();
menuWorld.position.set(-2,2,-3);
scene.add(menuWorld);

const menuHUD=new THREE.Group();
menuHUD.position.set(-1.3,0.35,-1.2);
menuHUD.scale.set(0.5,0.5,0.5);
camera.add(menuHUD);
scene.add(camera);

menuWorld.visible=false;

function makeButton(parent,label,y){
  const canvas=document.createElement('canvas');
  canvas.width=512; canvas.height=128;
  const ctx=canvas.getContext('2d');
  ctx.fillStyle="#111"; ctx.fillRect(0,0,512,128);
  ctx.fillStyle="#0f0"; ctx.font="48px Arial";
  ctx.textAlign="center"; ctx.textBaseline="middle";
  ctx.fillText(label,256,64);
  const tex=new THREE.CanvasTexture(canvas);
  const mat=new THREE.MeshBasicMaterial({map:tex});
  const mesh=new THREE.Mesh(new THREE.PlaneGeometry(0.8,0.2),mat);
  mesh.position.set(0,y,0);
  mesh.userData.group=label;
  parent.add(mesh);
  return mesh;
}

// Ribbon buttons
const rib1=makeButton(menuWorld,"Ribbon",0.7);
const rib2=makeButton(menuHUD,"Ribbon",0.7);

function toggleRibbon(){ ribbon.visible=!ribbon.visible; }

// Group buttons
const hudButtons=[];
Object.keys(groupDefs).forEach((g,i)=>{
  hudButtons.push(makeButton(menuHUD,g,0.3-i*0.3));
  makeButton(menuWorld,g,0.3-i*0.3);
});

// ===== MOUSE INTERACTION =====
const raycaster=new THREE.Raycaster();
const mouse=new THREE.Vector2();

window.addEventListener('contextmenu',e=>e.preventDefault());

window.addEventListener('mousedown',e=>{
  if(renderer.xr.isPresenting) return;

  mouse.x=(e.clientX/window.innerWidth)*2-1;
  mouse.y=-(e.clientY/window.innerHeight)*2+1;
  raycaster.setFromCamera(mouse,camera);
  const hits=raycaster.intersectObjects(menuHUD.children);

  if(!hits.length) return;
  const obj=hits[0].object;

  if(obj.userData.group==="Ribbon"){
    toggleRibbon();
    return;
  }

  const g=obj.userData.group;

  if(e.button===0){ // LEFT CLICK = TOGGLE VISIBILITY
    groupDefs[g].visible=!groupDefs[g].visible;
    recolorHelix();
  }

  if(e.button===2){ // RIGHT CLICK = EDIT GROUP
    currentEditGroup=g;
    inputBox.value=groupDefs[g].letters;
    inputBox.style.display="block";
    inputBox.focus();
  }
});

// ===== VR CONTROLLERS =====
const controllerL=renderer.xr.getController(0);
const controllerR=renderer.xr.getController(1);
scene.add(controllerL);
scene.add(controllerR);

function addLaser(ctrl){
  const g=new THREE.BufferGeometry().setFromPoints([new THREE.Vector3(),new THREE.Vector3(0,0,-1)]);
  const line=new THREE.Line(g,new THREE.LineBasicMaterial({color:0x00ff00}));
  line.scale.z=5;
  ctrl.add(line);
}
addLaser(controllerL); addLaser(controllerR);

function checkMenu(ctrl){
  const m=new THREE.Matrix4().identity().extractRotation(ctrl.matrixWorld);
  raycaster.ray.origin.setFromMatrixPosition(ctrl.matrixWorld);
  raycaster.ray.direction.set(0,0,-1).applyMatrix4(m);
  const hits=raycaster.intersectObjects(menuWorld.children);
  if(!hits.length) return;

  const g=hits[0].object.userData.group;
  if(g==="Ribbon") toggleRibbon();
  else{
    groupDefs[g].visible=!groupDefs[g].visible;
    recolorHelix();
  }
}

controllerL.addEventListener('selectstart',()=>checkMenu(controllerL));
controllerR.addEventListener('selectstart',()=>checkMenu(controllerR));

// ===== VR ROTATION =====
let rotating=false, activeCtrl=null;
let startPos=new THREE.Vector3(), startRotX=0, startRotY=0;
const ROT_SPEED=8;

function startRotate(c){ rotating=true; activeCtrl=c; startPos.copy(c.position); startRotX=helixGroup.rotation.x; startRotY=helixGroup.rotation.y; }
function stopRotate(){ rotating=false; }

controllerL.addEventListener('squeezestart',()=>startRotate(controllerL));
controllerL.addEventListener('squeezeend',stopRotate);
controllerR.addEventListener('squeezestart',()=>startRotate(controllerR));
controllerR.addEventListener('squeezeend',stopRotate);

renderer.xr.addEventListener('sessionstart',()=>{menuHUD.visible=false; menuWorld.visible=true;});
renderer.xr.addEventListener('sessionend',()=>{menuHUD.visible=true; menuWorld.visible=false;});

// ===== LOOP =====
renderer.setAnimationLoop(()=>{
  if(!renderer.xr.isPresenting) controls.update();
  if(rotating){
    const dx=activeCtrl.position.x-startPos.x;
    const dy=activeCtrl.position.y-startPos.y;
    helixGroup.rotation.y=startRotY+dx*ROT_SPEED;
    helixGroup.rotation.x=startRotX+dy*ROT_SPEED;
  }
  renderer.render(scene,camera);
});

window.addEventListener('resize',()=>{
  camera.aspect=window.innerWidth/window.innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(window.innerWidth,window.innerHeight);
});
</script>
</body>
</html>
